{
  "mainSnippet": {
    "prefix": "jj",
    "body": [
      "#include <bits/stdc++.h>",
      "#define ll            long long",
      "#define pb            push_back",
      "#define ld            long double",
      "#define sz            size()",
      "#define foo(i,a,b)    for (ll i=a;i<b;i++)",
      "#define pll           pair<ll,ll>",
      "#define ed            \"\\n\"",
      "#define ct            cout",
      "#define m_p           make_pair",
      "#define vi            vector<ll>",
      "#define vpll          vector<pll>",
      "#define ff            first",
      "#define ss            second",
      "#define all(x)        x.begin(),x.end()",
      "#define pqmax         priority_queue<ll>",
      "#define pqmin         priority_queue<ll,vector<ll>,greater<ll>>",
      "#define modulo        1000000007",
      "",
      "",
      "using namespace std;",
      "",
      "void bahut_tezz()",
      "{",
      "    #ifndef ONLINE_JUDGE",
      "        freopen(\"input.txt\", \"r\", stdin);",
      "        freopen(\"output.txt\", \"w\", stdout);",
      "    #endif",
      "    std::ios_base::sync_with_stdio(0);",
      "    cin.tie(0);",
      "    cout.tie(0);",
      "}",
      "/*--------------------------------------------------------------------------------------------------------------------------*/",
      "",
      "",
      "void jai_bajrangbali()",
      "{",
      "",
      "}",
      "",
      "int main()",
      "{",
      "    bahut_tezz();",
      "    long long t=1;",
      "    cin>>t;",
      "    while(t--)jai_bajrangbali();",
      "    return 0;",
      "}"
    ],
    "description": ""
  },
  "Combinations": {
    "prefix": "nCrmodp",
    "body": [
      "ll nCrModp(ll n, ll r, ll p = 1e18) ",
      "{ ",
      "    if (r > n - r) ",
      "        r = n - r; ",
      "  ",
      "    ll C[r + 1]; ",
      "    memset(C, 0, sizeof(C)); ",
      "    // This method is called Pascal Triangle ",
      "    C[0] = 1;",
      "    for (ll i = 1; i <= n; i++) ",
      "    {",
      "        for (ll j = min(i, r); j > 0; j--) ",
      "            C[j] = (C[j] + C[j - 1]) % p; ",
      "    } ",
      "    return C[r]; ",
      "}"
    ],
    "description": ""
  },
  "Prime number": {
    "prefix": "is_prime",
    "body": [
      "ll is_prime(ll n)",
      "{",
      "    for(ll i=2;i<=sqrt(n);i++)",
      "    {",
      "        if(n%i == 0)",
      "        {",
      "            return false;",
      "        }",
      "    }",
      "    return true;",
      "}"
    ],
    "description": ""
  },
  "Modular Exponentiation": {
    "prefix": "mod_pow",
    "body": [
      "ll mod_pow(ll x, ll y, ll p)",
      "{",
      "    ll res = 1; ",
      "    x = x % p;",
      "    if (x == 0) return 0; ",
      "    while (y > 0)",
      "    {",
      "        if (y & 1)",
      "            res = (res*x) % p;",
      "        y = y>>1;",
      "        x = (x*x) % p;",
      "    }",
      "    return res;",
      "}"
    ],
    "description": ""
  },
  "LCM": {
    "prefix": "lcm",
    "body": [
      "ll gcd(ll int a, ll int b)",
      "{",
      "  if (b == 0)",
      "    return a;",
      "  return gcd(b, a % b);",
      "}",
      "",
      "ll lcm(int a, int b)",
      "{",
      "    return (a / gcd(a, b)) * b;",
      "}"
    ],
    "description": ""
  },
  "Competetive Programming": {
    "prefix": "hadronCP",
    "body": [
      "/*",
      " * @hadron43, Expert soon",
      " * Good luck!",
      " */",
      "#include <bits/stdc++.h>",
      "using namespace std;",
      "",
      "#define modulo 1000000007",
      "#define maxsize 200000",
      "typedef long long ll;",
      "",
      "// vector<ll> arr;",
      "// map<ll, ll> m;",
      "ll T, n, in;",
      "",
      "void solve() {",
      "\t$0",
      "}",
      "",
      "int main() {",
      "\tcin>>T;",
      "\tfor(int t=0; t<T; ++t) {",
      "\t\tcin>>n;",
      "\t\tsolve();",
      "\t}",
      "}",
      ""
    ],
    "description": "cp boiler code"
  },

  "Binary Exponentiation": {
    "prefix": "_binpow",
    "body": [
      "ll binpow(ll a, ll b) {",
      "\ta %= modulo;",
      "\tll res = 1;",
      "\twhile (b > 0) {",
      "\t\tif (b & 1)",
      "\t\t\tres = res * a % modulo;",
      "\t\ta = a * a % modulo;",
      "\t\tb >>= 1;",
      "\t}",
      "\treturn res;",
      "}",
      ""
    ],
    "description": "Binary Exponentiation With Modulo"
  },

  "Modular Inverse": {
    "prefix": "_modinv",
    "body": ["ll modinv(ll a) { return binpow(a, modulo-2); }\n"],
    "description": "Modular Inverse Algorithm"
  },

  "Greatest Common Divisor": {
    "prefix": "_gcd",
    "body": "ll gcd(ll a, ll b) { if (a == 0) return b; return gcd(b % a, a); }\n",
    "description": "Euclid Algorithm for returning the gcd of two integers"
  },

  "Merge Sort": {
    "prefix": "_mergesort",
    "body": [
      "void merge(vector<ll> &v, int l, int r, int mid) {",
      "    vector<ll> vt;",
      "    int i = l, j = mid;",
      "    while(i<mid && j<r)",
      "        if(v[i] <= v[j])",
      "            vt.push_back(v[i++]);",
      "        else {",
      "            vt.push_back(v[j++]);",
      "//            inversions += (mid - i);",
      "        }",
      "",
      "    while(i < mid)",
      "        vt.push_back(v[i++]);",
      "    while(j < r)",
      "        vt.push_back(v[j++]);",
      "",
      "    for(int i=0; i<vt.size(); ++i)",
      "        v[i+l] = vt[i];",
      "}",
      "",
      "void mergesort(vector<ll> &v, int l, int r) {",
      "    if(l+1 >= r)",
      "        return;",
      "    int mid = (l+r) / 2;",
      "    mergesort(v, l, mid);",
      "    mergesort(v, mid, r);",
      "    merge(v, l, r, mid);",
      "}"
    ],
    "description": "Divide and Conquer algorithm for sorting an array"
  },

  "Segment Tree": {
    "prefix": "_seg_tree",
    "body": [
      "struct seg_tree {",
      "    int n;",
      "    vector<int> t;",
      "",
      "    void build(vector<int> a, int v, int tl, int tr) {",
      "        t.resize(4*a.size());",
      "        if (tl == tr) {",
      "            t[v] = a[tl];",
      "        } else {",
      "            int tm = (tl + tr) / 2;",
      "            build(a, v*2, tl, tm);",
      "            build(a, v*2+1, tm+1, tr);",
      "            t[v] = t[v*2] + t[v*2+1];",
      "        }",
      "    }",
      "",
      "    int sum(int v, int tl, int tr, int l, int r) {",
      "        if (l > r) ",
      "            return 0;",
      "        if (l == tl && r == tr) {",
      "            return t[v];",
      "        }",
      "        int tm = (tl + tr) / 2;",
      "        return sum(v*2, tl, tm, l, min(r, tm))",
      "            + sum(v*2+1, tm+1, tr, max(l, tm+1), r);",
      "    }",
      "",
      "    void update(int v, int tl, int tr, int pos, int new_val) {",
      "        if (tl == tr) {",
      "            t[v] = new_val;",
      "        } else {",
      "            int tm = (tl + tr) / 2;",
      "            if (pos <= tm)",
      "                update(v*2, tl, tm, pos, new_val);",
      "            else",
      "                update(v*2+1, tm+1, tr, pos, new_val);",
      "            t[v] = t[v*2] + t[v*2+1];",
      "        }",
      "    }",
      "};",
      ""
    ],
    "description": "Segment Tree from cp-algorithms.com"
  }
}
